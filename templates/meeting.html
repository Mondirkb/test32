<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Room - {{ room_id }}</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    
    <style>

    </style>
</head>
<body>
    <div class="meeting-container">
        <div class="debug-info" id="debugInfo">
            Room: {{ room_id }}<br>
            Socket: Connecting...<br>
            Participants: 0<br>
            Connection: None
        </div>
        
        <div class="header">
            <h2>Meeting Room: {{ room_id }}</h2>
            <p>Welcome, {{ username }}!</p>
        </div>
        
        <div class="container-fluid py-4">
            <div class="row justify-content-center">
                <div class="col-md-5 col-12 mb-3">
                    <div class="card bg-dark">
                        <div class="card-header text-white">You ({{ username }})</div>
                        <div class="card-body p-0">
                            <div class="video-wrapper">
                                <video id="localVideo" class="local-video" autoplay muted playsinline></video>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-7 col-12 mb-3">
                    <div class="card bg-dark">
                        <div class="card-header text-white">Remote Participant</div>
                        <div class="card-body p-0">
                            <div class="video-wrapper">
                                <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row justify-content-center">
                <div class="col-12 text-center">
                    <button id="startCall" class="btn btn-success mx-2">Start Call</button>
                    <button id="muteBtn" class="btn btn-secondary mx-2">Mute</button>
                    <button id="videoBtn" class="btn btn-secondary mx-2">Turn Off Video</button>
                    <button id="leaveBtn" class="btn btn-danger mx-2">Leave Meeting</button>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div id="statusMsg" class="status info">Initializing meeting room...</div>
            
            <div class="mt-3">
                <a href="{{ url_for('dashboard') }}" class="control-btn secondary">Back to Dashboard</a>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
        // Configuration - HTTPS signaling server
        const SIGNALING_SERVER = `${window.location.protocol}//${window.location.hostname}:5001`;
        const STUN_SERVERS = { 
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun.relay.metered.ca:80' }, // Correct STUN server
                { 
                    urls: 'turn:global.relay.metered.ca:80', 
                    username: '5fdcd135037ca105d289b7c3', 
                    credential: 'z1H82IWfwf10Kmd7' 
                },
                { 
                    urls: 'turn:global.relay.metered.ca:443', 
                    username: '5fdcd135037ca105d289b7c3', 
                    credential: 'z1H82IWfwf10Kmd7' 
                },
                { 
                    urls: 'turns:global.relay.metered.ca:443?transport=tcp', 
                    username: '5fdcd135037ca105d289b7c3', 
                    credential: 'z1H82IWfwf10Kmd7' 
                }
            ]
        };
        
        // Global variables
        let socket; 
        let localStream = null;
        let peerConnection = null;
        let isCallStarted = false;
        let isMuted = false;
        let isVideoOff = false;
        let isInitiator = false;
        let roomParticipants = 0;
        
        const roomID = "{{ room_id }}";
        const username = "{{ username }}";
        
        // DOM elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startCallBtn = document.getElementById('startCall');
        const muteBtn = document.getElementById('muteBtn');
        const videoBtn = document.getElementById('videoBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const statusMsg = document.getElementById('statusMsg');
        const debugInfo = document.getElementById('debugInfo');
        
        // Debug function
        function updateDebug(info) {
            const now = new Date().toLocaleTimeString();
            debugInfo.innerHTML = `
                Room: ${roomID}<br>
                Socket: ${socket ? (socket.connected ? 'Connected' : 'Disconnected') : 'Not initialized'}<br>
                Participants: ${roomParticipants}<br>
                Connection: ${peerConnection ? peerConnection.connectionState : 'None'}<br>
                Last Update: ${now}<br>
                ${info || ''}
            `;
        }
        
        // Initialize webcam immediately when page loads
        async function initializeWebcam() {
            try {
                console.log("ðŸŽ¥ Requesting user media...");
                updateStatus('Requesting camera access...', 'info');
                
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640, max: 1280 }, 
                        height: { ideal: 480, max: 720 },
                        facingMode: 'user'
                    }, 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                localVideo.srcObject = localStream;
                console.log(" Local video stream started");
                
                muteBtn.disabled = false;
                videoBtn.disabled = false;
                updateStatus('Camera ready. Connecting to meeting room...', 'info');
                updateDebug('Local video ready');
                
                // Now initialize socket connection
                initializeSocket();
                
            } catch (error) {
                console.error(' Error accessing media devices:', error);
                updateStatus('Could not access camera/microphone: ' + error.message, 'warning');
                updateDebug('Camera error: ' + error.message);
                
                // Still try to connect to socket for text communication
                initializeSocket();
            }
        }
        
        // Initialize socket connection
        function initializeSocket() {
            console.log(" Connecting to signaling server:", SIGNALING_SERVER);
            updateStatus('Connecting to signaling server...', 'info');
            updateDebug('Connecting to signaling server...');
            
            socket = io(SIGNALING_SERVER, {
                transports: ['websocket', 'polling'],
                timeout: 20000,
                forceNew: true,
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                maxReconnectionAttempts: 5
            });
            
            // Connection events
            socket.on('connect', () => {
                console.log(' Connected to signaling server with ID:', socket.id);
                updateStatus('Connected to signaling server', 'success');
                updateDebug('Connected as: ' + socket.id);
                
                // Join the room immediately after connection
                console.log(' Joining room:', roomID);
                socket.emit('join-room', { room: roomID });
            });
            
            socket.on('connection-confirmed', (data) => {
                console.log(' Connection confirmed:', data);
                updateDebug('Connection confirmed: ' + data.id);
            });
            
            socket.on('connect_error', (error) => {
                console.error(' Connection error:', error);
                updateStatus('Failed to connect to signaling server: ' + error.message, 'warning');
                updateDebug('Connection error: ' + error.message);
            });
            
            socket.on('disconnect', () => {
                console.log(' Disconnected from signaling server');
                updateStatus('Disconnected from signaling server', 'warning');
                updateDebug('Disconnected');
            });
            
            // Room events
            socket.on('room-joined', (data) => {
                console.log(' Room joined confirmation:', data);
                roomParticipants = data.participants;
                updateDebug('Joined room, participants: ' + roomParticipants);
            });
            
            socket.on('waiting-for-participants', (data) => {
                console.log(' Waiting for participants:', data);
                roomParticipants = data.participants;
                updateStatus(`You're in the room. Waiting for other participants... (${data.participants}/2)`, 'info');
                updateDebug('Waiting for participants: ' + data.participants);
            });
            
            socket.on('user-joined', (data) => {
                console.log(' User joined:', data);
                roomParticipants = data.total_participants;
                updateStatus('Another user joined the room. Ready to start call!', 'success');
                updateDebug('User joined, total: ' + data.total_participants);
            });
            
            socket.on('room-ready', (data) => {
                console.log(' Room ready:', data);
                roomParticipants = data.participants;
                updateStatus(`Room ready! ${data.participants} participants. Click "Start Video Call" to connect.`, 'success');
                startCallBtn.textContent = "Start Video Call";
                startCallBtn.disabled = false;
                updateDebug('Room ready with ' + data.participants + ' participants');
            });
            
            // WebRTC signaling events
            socket.on('offer', async (data) => {
                console.log(' Received offer from:', data.from);
                updateDebug('Received offer from: ' + data.from);
                if (!isInitiator) {
                    await handleOffer(data.offer);
                }
            });
            
            socket.on('answer', async (data) => {
                console.log(' Received answer from:', data.from);
                updateDebug('Received answer from: ' + data.from);
                if (isInitiator && peerConnection) {
                    await handleAnswer(data.answer);
                }
            });
            
            socket.on('ice-candidate', async (data) => {
                console.log(' Received ICE candidate from:', data.from);
                if (peerConnection) {
                    await handleIceCandidate(data.candidate);
                }
            });
            
            socket.on('user-left', (data) => {
                console.log(' User left:', data.user);
                roomParticipants = data.remaining_participants || 0;
                updateStatus('Other participant left the room', 'warning');
                updateDebug('User left, remaining: ' + roomParticipants);
                resetCall();
            });
        }
        
        // Update status message
        function updateStatus(message, type) {
            statusMsg.textContent = message;
            statusMsg.className = `status ${type}`;
            console.log(` Status: ${message}`);
        }
        
        // Create peer connection
        function createPeerConnection() {
            console.log(" Creating peer connection...");
            updateDebug('Creating peer connection...');
            
            peerConnection = new RTCPeerConnection(STUN_SERVERS);
            
            // Add local stream tracks to peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    console.log(" Adding track:", track.kind);
                    peerConnection.addTrack(track, localStream);
                });
                updateDebug('Added local tracks to peer connection');
            }
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(' Sending ICE candidate');
                    socket.emit('ice-candidate', {
                        room: roomID,
                        candidate: event.candidate
                    });
                }
            };
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log(' Received remote track:', event.streams[0]);
                remoteVideo.srcObject = event.streams[0];
                updateStatus('Video call connected! ðŸŽ‰', 'success');
                updateDebug('Remote stream connected');
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log(' Connection state:', state);
                updateDebug('Connection state: ' + state);
                
                switch (state) {
                    case 'connected':
                        updateStatus('Peer connection established successfully', 'success');
                        break;
                    case 'disconnected':
                        updateStatus('Peer disconnected', 'warning');
                        break;
                    case 'failed':
                        updateStatus('Connection failed. Please try again.', 'warning');
                        resetCall();
                        break;
                    case 'connecting':
                        updateStatus('Connecting to peer...', 'info');
                        break;
                }
            };
            
            peerConnection.oniceconnectionstatechange = () => {
                console.log(' ICE connection state:', peerConnection.iceConnectionState);
            };
        }
        
        // Handle incoming offer
        async function handleOffer(offer) {
            console.log(" Handling incoming offer...");
            updateStatus('Incoming call...', 'info');
            
            if (!peerConnection) {
                createPeerConnection();
            }
            
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                console.log(" Remote description set for offer");
                
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log(" Local description set with answer");
                
                socket.emit('answer', {
                    room: roomID,
                    answer: answer
                });
                console.log("ðŸ“ž Answer sent");
                
                updateStatus('Answering call...', 'info');
                updateDebug('Call answered');
                
            } catch (error) {
                console.error(' Error handling offer:', error);
                updateStatus('Error establishing connection: ' + error.message, 'warning');
                updateDebug('Error handling offer: ' + error.message);
            }
        }
        
        // Handle incoming answer
        async function handleAnswer(answer) {
            console.log(" Handling incoming answer...");
            if (!peerConnection) {
                console.error("PeerConnection is not initialized.");
                return;
            }
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(" Remote description set with answer");
                updateDebug('Answer processed successfully');
            } catch (error) {
                console.error(' Error handling answer:', error);
                updateStatus('Error completing connection: ' + error.message, 'warning');
                updateDebug('Error handling answer: ' + error.message);
            }
        }
        
        // Handle incoming ICE candidate
        async function handleIceCandidate(candidate) {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log(" ICE candidate added");
            } catch (error) {
                console.error(' Error adding ICE candidate:', error);
            }
        }
        
        // Start call function
        async function startCall() {
            console.log(" Starting call...");
            isInitiator = true;
            updateDebug('Initiating call...');
            
            try {
                updateStatus('Initiating call...', 'info');
                
                if (!peerConnection) {
                    createPeerConnection();
                }
                
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await peerConnection.setLocalDescription(offer);
                console.log(" Local description set with offer");
                
                socket.emit('offer', {
                    room: roomID,
                    offer: offer
                });
                
                console.log(" Offer sent");
                startCallBtn.disabled = true;
                startCallBtn.textContent = "Calling...";
                isCallStarted = true;
                updateDebug('Call initiated, waiting for answer');
                
            } catch (error) {
                console.error(' Error starting call:', error);
                updateStatus('Error starting call: ' + error.message, 'warning');
                updateDebug('Error starting call: ' + error.message);
            }
        }
        
        // Reset call state
        function resetCall() {
            console.log(" Resetting call state");
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            remoteVideo.srcObject = null;
            isCallStarted = false;
            isInitiator = false;
            startCallBtn.disabled = false;
            startCallBtn.textContent = roomParticipants > 1 ? "Start Video Call" : "Ready to Call";
            updateStatus('Call ended. Ready for new connection.', 'info');
            updateDebug('Call reset');
        }
        
        // Toggle mute
        function toggleMute() {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                audioTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                isMuted = !isMuted;
                muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
                muteBtn.className = isMuted ? 'control-btn danger' : 'control-btn secondary';
                updateStatus(isMuted ? 'Microphone muted' : 'Microphone unmuted', 'info');
                updateDebug('Audio ' + (isMuted ? 'muted' : 'unmuted'));
            }
        }
        
        // Toggle video
        function toggleVideo() {
            if (localStream) {
                const videoTracks = localStream.getVideoTracks();
                videoTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                isVideoOff = !isVideoOff;
                videoBtn.textContent = isVideoOff ? 'Turn On Video' : 'Turn Off Video';
                videoBtn.className = isVideoOff ? 'control-btn danger' : 'control-btn secondary';
                updateStatus(isVideoOff ? 'Camera turned off' : 'Camera turned on', 'info');
                updateDebug('Video ' + (isVideoOff ? 'disabled' : 'enabled'));
            }
        }
        
        // Leave meeting
        function leaveMeeting() {
            console.log(" Leaving meeting...");
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (socket) {
                socket.emit('leave-room', { room: roomID });
                socket.disconnect();
            }
            
            window.location.href = "{{ url_for('dashboard') }}";
        }
        
        // Event listeners
        startCallBtn.addEventListener('click', startCall);
        muteBtn.addEventListener('click', toggleMute);
        videoBtn.addEventListener('click', toggleVideo);
        leaveBtn.addEventListener('click', leaveMeeting);
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (socket) {
                socket.emit('leave-room', { room: roomID });
            }
        });
        
        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Page loaded, initializing meeting room...");
            updateStatus('Initializing camera...', 'info');
            updateDebug('Page loaded, starting initialization...');
            
            // Start the initialization process
            initializeWebcam();
            
            // Update debug info every 2 seconds
            setInterval(() => {
                updateConnectionStats(); // Fetch WebRTC stats periodically
            }, 2000);
        });
        
        // Add periodic connection health check
        setInterval(() => {
            if (socket && !socket.connected) {
                console.log(" Socket disconnected, attempting to reconnect...");
                updateStatus('Connection lost, reconnecting...', 'warning');
                initializeSocket();
            }
        }, 10000);

        // Update connection stats
        async function updateConnectionStats() {
            if (!peerConnection) {
                console.warn("PeerConnection is not initialized.");
                return;
            }

            if (peerConnection.connectionState !== "connected") {
                console.warn("PeerConnection is not connected.");
                return;
            }

            try {
                const stats = await peerConnection.getStats();
                let bandwidth = 0;
                let jitter = 0;
                let rtt = 0;
                let packetsLost = 0;

                stats.forEach(report => {
                    // Bandwidth: Check for outbound-rtp (sent video/audio)
                    if (report.type === "outbound-rtp" && report.kind === "video") {
                        bandwidth = report.bytesSent; // Total bytes sent
                    }

                    // Jitter and Packet Loss: Check for inbound-rtp (received video/audio)
                    if (report.type === "inbound-rtp" && report.kind === "video") {
                        jitter = report.jitter || 0; // Jitter in seconds
                        packetsLost = report.packetsLost || 0; // Total packets lost
                    }

                    // RTT: Check for candidate-pair (round-trip time)
                    if (report.type === "candidate-pair" && report.currentRoundTripTime) {
                        rtt = report.currentRoundTripTime; // RTT in seconds
                    }
                });

                // Convert values to readable formats
                bandwidth = (bandwidth / 1024).toFixed(2) + " KB"; // Convert bytes to KB
                jitter = (jitter * 1000).toFixed(2) + " ms"; // Convert seconds to milliseconds
                rtt = (rtt * 1000).toFixed(2) + " ms"; // Convert seconds to milliseconds

                // Update debug info
                updateDebug(`
                    Bandwidth: ${bandwidth}<br>
                    Jitter: ${jitter}<br>
                    RTT: ${rtt}<br>
                    Packet Loss: ${packetsLost} packets
                `);
            } catch (error) {
                console.error("Error fetching WebRTC stats:", error);
            }
        }

        console.log("Local Stream:", localStream);
        console.log("Remote Stream:", remoteVideo.srcObject);
    </script>
</body>
</html>